package com.kenny.craftix.client.renderer;

import java.nio.ByteBuffer;
import java.nio.DoubleBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.nio.ShortBuffer;

import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL12;
import org.lwjgl.opengl.GL13;
import org.lwjgl.opengl.GL14;
import org.lwjgl.opengl.GL15;
import org.lwjgl.opengl.GL20;
import org.lwjgl.opengl.GL30;
import org.lwjgl.opengl.GL31;
import org.lwjgl.opengl.GL32;
import org.lwjgl.opengl.GL33;

public class GlHelper 
{
	/**
	 * Here a all disable and enable fuctions.
	 */
	
	/**
	 * This method enable parameters from OpenGl, such as TEXTURE_2D or TEXTURE_PROXY_2D.
	 */
	public static void enable(int param)
	{
		GL11.glEnable(param);
	}
	
	/**
	 * This method disable parameters from OpenGl, such as TEXTURE_2D or TEXTURE_PROXY_2D.
	 */
	public static void disable(int param)
	{
		GL11.glDisable(param);
	}
	
	public static void enableTexture2d()
	{
		enable(Texture.TEXTURE_2D);
	}
	
	public static void disableTexture2d()
	{
		disable(Texture.TEXTURE_2D);
	}
	
	public static void enableDepthTest()
	{
		enable(GL11.GL_DEPTH_TEST);
	}
	
	public static void disableDepthTest()
	{
		disable(GL11.GL_DEPTH_TEST);
	}
	
	public static void enableCulling()
	{
		enable(GL11.GL_CULL_FACE);
		GlHelper.glCullFace(Texture.BACK);
	}
	
	public static void disableCulling()
	{
		disable(GL11.GL_CULL_FACE);
	}
	
	/**
	 * Enable the blend factor.
	 */
	public static void enableBlend()
	{
		enable(Blend.BLEND);
	}
	
	/**
	 * Disable the blend factor.
	 */
	public static void disableBlend()
	{
		disable(Blend.BLEND);
	}
	
	public static void enablePoligonMode()
	{
		GL11.glLineWidth(2f);
		GL11.glPolygonMode(Texture.FRONT_AND_BACK, Texture.LINE);
	}
	
	public static void disablePoligonMode()
	{
		GL11.glPolygonMode(Texture.FRONT_AND_BACK, Texture.FILL);
	}
	
	/**
	 * By default be enable ClipDistance0. In Texture class you can change the clip-distance or add new.
	 */
	public static void enableClipDistance()
	{
		enable(Texture.CLIP_DISTANCE);
	}
	
	/**
	 * By default be disable ClipDistance0. In Texture class you can change the clip-distance or add new.
	 */
	public static void disableClipDistance()
	{
		disable(Texture.CLIP_DISTANCE);
	}
	
	/**
	 * Multisampling, also known as multisample antialiasing (MSAA), is one method 
	 * for achieving full-screen antialiasing (FSAA). With multisampling, each pixel
	 * at the edge of a polygon is sampled multiple times. For each sample-pass, a slight offset
 	 * is applied to all screen coordinates. This offset is smaller than the actual size of the 
 	 * pixels.
	 */
	
	
	public static void enableMultisample()
	{
		enable(GL13.GL_MULTISAMPLE);
	}
	
	public static void disableMultisample()
	{
		disable(GL13.GL_MULTISAMPLE);
	}
	
	
	/**The Vertex Shader (VS) is the programmable Shader stage in the rendering pipeline that handles 
	 * the processing of individual vertices. Vertex shaders are fed Vertex Attribute data, as 
	 * specified from a vertex array object by a drawing command. A vertex shader receives a 
	 * single vertex from the vertex stream and generates a single vertex to the output vertex 
	 * stream. There must be a 1:1 mapping from input vertices to output vertices.
	 */
	public static int vertexShader()
	{
		int vertexShader;
		vertexShader = GL20.GL_VERTEX_SHADER;
			return vertexShader;
	}
	
	/**
	 * A Fragment Shader (FS) is the Shader stage that will process a Fragment generated by 
	 * the Rasterization into a set of colors and a single depth value. The fragment shader 
	 * is the OpenGL pipeline stage after a primitive is rasterized. For each sample of the pixels 
	 * covered by a primitive, a "fragment" is generated.
	 */
	public static int fragmentShader()
	{
		int fragmentShader;
		fragmentShader = GL20.GL_FRAGMENT_SHADER;
			return fragmentShader;
	}
	
	/**
	 * A Geometry Shader (GS) is a Shader program written in GLSL that governs the processing 
	 * of Primitives. Geometry shaders reside between the Vertex Shaders (or the optional 
	 * Tessellation stage) and the fixed-function Vertex Post-Processing stage.A geometry shader 
	 * is optional and does not have to be used.
	 */
	public static int geometryShader()
	{
		int geometryShader;
		geometryShader = GL32.GL_GEOMETRY_SHADER;
			return geometryShader;
	}
	
	/**
	 * Set or choose the matrix mode.
	 */
	public static void glMatrixMode(int mode)
	{
		GL11.glMatrixMode(mode);
		
	}
	
	public static void tryBlendFuncSeperate(int sFactorRGB, int dFactorRGB, int sFactorAlpha, int dFactorAlpha)
	{
		GL14.glBlendFuncSeparate(sFactorRGB, dFactorRGB, sFactorAlpha, dFactorAlpha);
	}
	
	/**
	 * Load a identity matrix.
	 */
	public static void glLoadIdentity()
	{
		GL11.glLoadIdentity();
	}
	
	/**
	 * A 2d view should be sufficient for drawing a quad, 
	 * this will be set by using an orthographic matrix.
	 */
	public static void glOrtho(double left, double right, double buttom, double top,
			double zNear, double zFar)
	{
		GL11.glOrtho(left, right, buttom, top, zNear, zFar);
	}
	
	/**
	 * Clear the screen for draw and other buffer: (GL11.A | GL11.B).        
	 * Example glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
	 */
	public static void glClear(int mask)
	{
		GL11.glClear(mask); 
	}
	
	/**
	 * Sets the color of the quad on floats.
	 */
	public static void glColor3f(float r, float g, float b)
	{
		GL11.glColor3f(r, g, b);
	}
	
	/**
	 * Sets the color of the quad on doubles.
	 */
	public static void glColor3d(double r, double g, double b)
	{
		GL11.glColor3d(r, g, b);
	}
	
	/**
	 * Sets the color of the quad on bytes.
	 */
	public static void glColor3b(byte r, byte g, byte b)
	{
		GL11.glColor3b(r, g, b);
	}
	
	/**
	 * Clear all colors from previuse update.
	 */
	public static void glClearColor(float r, float b, float g, float a)
	{
		GL11.glClearColor(r, g, b, a);
	}
	
	public static void glEnable(int cap)
	{
		GL11.glEnable(cap);
	}
	
	public static void glDisable(int cap)
	{
		GL11.glDisable(cap);
	}
	
	public static void glCullFace(int mode)
	{
		GL11.glCullFace(mode);
	}

	public static void glBlendFunction(int sfactor, int dfactor)
	{
		GL11.glBlendFunc(sfactor, dfactor);
	}
	
	/**
	 * This is necessary in order to start drawing. For example in lines, 
	 * quads, triangles.
	 */
	public static void glBegin(int mode)
	{
		GL11.glBegin(mode);
	}
	
	/**
	 * End of drawing.
	 */
	public static void glEnd()
	{
		GL11.glEnd();
	}
	
	/**
	 * 2D drawing. These methods specify the coordinates of the points 
	 * to connect and convert them to quads, lines, or triangles.
	 * This methods can be in floats, ints, doubles.
	 */
	
	
	public static void glVertex2f(float x, float y)
	{
		GL11.glVertex2f(x, y);
	}
	
	public static void glVertex2d(double x, double y)
	{
		GL11.glVertex2d(x, y);
	}
	
	public static void glVertex2i(int x, int y)
	{
		GL11.glVertex2i(x, y);
	}
	
	
	/**
	 * Draw the quad on the center.
	 */
	public static void glTranslatef(float x, float y, float z)
	{
		GL11.glTranslatef(x, y, z);
	}
	
	/**
	 * Draw arrays on the screen.
	 */
	public static void glDrawArrays(int mode, int first, int count)
	{
		GL11.glDrawArrays(mode, first, count);
	}
	
	/**
	 * Draw arrays in byte buffer.
	 */
	public static void glDrawElements(int mode, ByteBuffer indices)
	{
		GL11.glDrawElements(mode, indices);
	}
	
	/**
	 * Draw arrays in int buffer.
	 */
	public static void glDrawElements(int mode, IntBuffer indices)
	{
		GL11.glDrawElements(mode, indices);
	}
	
	/**
	 * Draw arrays in short buffer.
	 */
	public static void glDrawElements(int mode, ShortBuffer indices)
	{
		GL11.glDrawElements(mode, indices);
	}
	
	public static void glDrawElements(int mode, int indices_count, int type, long buffer)
	{
		GL11.glDrawElements(mode, indices_count, type, buffer);
	}
	
	/**
	 * Draw buffer to current mode.
	 */
	public static void glDrawBuffers(int mode)
	{
		GL11.glDrawBuffer(mode);
	}
	
	public static void glDrawBuffers(IntBuffer buffers) 
	{
		GL20.glDrawBuffers(buffers);
	}
	
	/**
	 * Just a read current buffer.
	 */
	public static void glReadBuffer(int mode)
	{
		GL11.glReadBuffer(mode);
	}
	
	public static void glBindRenderbuffer(int renderBuffer)
	{
		GL30.glBindRenderbuffer(Framebuffer.RENDERBUFFER, renderBuffer);
	}
	
	/**
	 * Genetate a texture for maps.
	 */
	public static int glGenTextures()
	{
		return GL11.glGenTextures();
	}
	
	/**
	 * Generate a arrays for vertecies.
	 */
	public static int glGenVertexArrays()
	{
		return GL30.glGenVertexArrays();
	}
	
	/**
	 * This is the viewport for the camera or player.
	 */
	public static void glViewport(int x, int y, int width, int height)
	{
		GL11.glViewport(x, y, width, height);
	}
	
	/**
	 * Bind a vertex arrays.
	 */
	public static void glBindVertexArray(int array)
	{
		GL30.glBindVertexArray(array);
	}
	
	/**
	 * Delete all vertex arrays from buffers.
	 */
	public static void glDeleteVertexArrays(int arrays)
	{
		GL30.glDeleteVertexArrays(arrays);
	}
	
	/**
	 * Bind a frame buffers.
	 */
	public static void glBindFramebuffers(int target, int framebuffer)
	{
		GL30.glBindFramebuffer(target, framebuffer);
	}
	
	/**
	 * Bind a render buffers.
	 */
	public static void glBindRenderbuffers(int target, int renderbuffer)
	{
		GL30.glBindRenderbuffer(target, renderbuffer);
	}
	
	/**
	 * Bind a buffers.
	 */
	public static void glBindBuffer(int target, int buffer)
	{
		GL15.glBindBuffer(target, buffer);
	}
	
	/**
	 * Delete all buffers.
	 */
	public static void glDeleteBuffers(int buffer)
	{
		GL15.glDeleteBuffers(buffer);
	}

	/**
	 * Generate a buffres ids for 2d or 3d models. 
	 */
	public static int glGenBuffers()
	{
		return GL15.glGenBuffers();
	}
	
	/**
	 * Set the buffer data in long.
	 */
	public static void glBufferData(int target, long data, int usage)
	{
		GL15.glBufferData(target, data, usage);
	}
	
	/**
	 * Set the buffer data in integers.
	 */
	public static void glBufferData(int target, IntBuffer data, int usage)
	{
		GL15.glBufferData(target, data, usage);
	}
	
	/**
	 * Set the buffer data in floatss.
	 */
	public static void glBufferData(int target, FloatBuffer data, int usage)
	{
		GL15.glBufferData(target, data, usage);
	}
	
	
	public static void glVertexAttribPointer(int index, int size, boolean normalized, int stride, DoubleBuffer buffer)
	{
		GL20.glVertexAttribPointer(index, size, normalized, stride, buffer);
	}
	
	public static void glVertexAttribPointer(int index, int size, int type, boolean normalized, int stride, long buffer_offset)
	{
		GL20.glVertexAttribPointer(index, size, type, normalized, stride, buffer_offset);
	}
	
	public static void glEnableVertexAttribArray(int index)
	{
		GL20.glEnableVertexAttribArray(index);
	}
	
	public static void glDisableVertexAttribArray(int index)
	{
		GL20.glDisableVertexAttribArray(index);
	}
	
	public static void glBindAttribLocation(int program, int index, ByteBuffer name)
	{
		GL20.glBindAttribLocation(program, index, name);
	}
	
	public static void glBindAttribLocation(int program, int index, CharSequence name)
	{
		GL20.glBindAttribLocation(program, index, name);
	}
	
	public static void glBindAttribLocation(int program, int index, String name)
	{
		GL20.glBindAttribLocation(program, index, name);
	}
	
	/**
	 * Just a create a basic shader program.
	 * @return 
	 */
	public static int glCreateShader(int type)
	{
		return GL20.glCreateShader(type);
	}
	
	/**
	 * Create a program for shaders.
	 */
	public static int glCreateProgram()
	{
		return GL20.glCreateProgram();
	}
	
	public static void glShaderSource(int shader, ByteBuffer string)
	{
		GL20.glShaderSource(shader, string);
	}
	
	public static void glShaderSource(int shader, CharSequence string)
	{
		GL20.glShaderSource(shader, string);
	}
	
	/***
	 * Get a shader in integers.
	 */
	public static void glGetShaderi(int shader, int pname)
	{
		GL20.glGetShaderi(shader, pname);
	}
	
	/**
	 * Get a shader.
	 */
	@SuppressWarnings("deprecation")
	public static void glGetShader(int shader, int pname)
	{
		GL20.glGetShader(shader, pname);
	}
	
	/**
	 * Get a shader information log. Information about shader/s.
	 */
	public static String glGetShaderInfoLog(int shader, int maxLength) 
	{
		return GL20.glGetShaderInfoLog(shader, maxLength);
	}

	/**
	 * Compile shader into java code from GLSL.
	 */
	public static void glCompileShader(int shaderID) 
	{
		GL20.glCompileShader(shaderID);
	}
	
	/**
	 * Delete a shader from previus frame or on pre-close game.
	 */
	public static void glDeleteShader(int shader)
	{
		GL20.glDeleteShader(shader);
	}
	
	/**
	 * This method just connect type of shader and ID for him.
	 */
	public static void glAttachShader(int program, int shader)
	{
		GL20.glAttachShader(program, shader);
	}
	
	/**
	 * This method just deconnect type of shader and ID for him.
	 */
	public static void glDetachShader(int program, int shader)
	{
		GL20.glDetachShader(program, shader);
	}
	
	/**
	 * Here we get the link to the program.
	 */
	public static void glLinkProgram(int program)
	{
		GL20.glLinkProgram(program);
	}
	
	public static void glValidateProgram(int program)
	{
		GL20.glValidateProgram(program);
	}
	
	public static void glUseProgram(int program)
	{
		GL20.glUseProgram(program);
	}
	
	public static void glDeleteProgram(int program)
	{
		GL20.glDeleteProgram(program);
	}
	
	public static void glDeleteTextures(int texture)
	{
		GL11.glDeleteTextures(texture);
	}
	
	public static void glDeleteFramebuffers(int framebuffer)
	{
		GL30.glDeleteFramebuffers(framebuffer);
	}
	
	public static void glDeleteFramebuffers(IntBuffer framebuffers)
	{
		GL30.glDeleteFramebuffers(framebuffers);
	}
	
	public static void glDeleteRenderbuffers(int framebuffer)
	{
		GL30.glDeleteRenderbuffers(framebuffer);
	}
	
	public static void glDeleteRenderbuffers(IntBuffer framebuffer)
	{
		GL30.glDeleteRenderbuffers(framebuffer);
	}
	
	/**
	 * Active textures for current id for future using.
	 */
	public static void glActiveTexture(int texture)
	{
		GL13.glActiveTexture(texture);
	}
	
	/**
	 * Bind a texture.
	 */
	public static void glBindTexture(int target, int texture)
	{
		GL11.glBindTexture(target, texture);
	}
	
	/**
	 * Here we get a uniform location in shaders files.
	 */
	public static int glGetUniformLocation(int program, ByteBuffer name)
	{
		return GL20.glGetUniformLocation(program, name);
	}
	
	/**
	 * Here we get a uniform location in shaders files on string varibles.
	 */
	public static int glGetUniformLocation(int program, String name) 
	{
		return GL20.glGetUniformLocation(program, name);
	}
	
	/**
	 * Here we get a uniform on floats.
	 */
	public static void glGetUniform(int program, int location, FloatBuffer params)
	{
		GL20.glGetUniform(program, location, params);
	}
	
	/**
	 * Here we get a uniform on integers.
	 */
	public static void glGetUniform(int program, int location, IntBuffer params)
	{
		GL20.glGetUniform(program, location, params);
	}
	
	/**
	 * Get Uniforms methods.
	 * ============================
	 */
	
	public static void glUniform1f(int location, float v0)
	{
		GL20.glUniform1f(location, v0);
	}
	
	public static void glUniform1i(int location, int v0)
	{
		GL20.glUniform1i(location, v0);
	}
	
	public static void glUniform1(int location, IntBuffer values)
	{
		GL20.glUniform1(location, values);
	}
	
	public static void glUniform1(int location, FloatBuffer values)
	{
		GL20.glUniform1(location, values);
	}
	
	public static void glUniform2f(int location, float v0, float v1)
	{
		GL20.glUniform2f(location, v0, v1);
	}
	
	public static void glUniform2i(int location, int v0, int v1)
	{
		GL20.glUniform2i(location, v0, v1);
	}
	
	public static void glUniform2(int location, IntBuffer values)
	{
		GL20.glUniform2(location, values);
	}
	
	public static void glUniform2(int location, FloatBuffer values)
	{
		GL20.glUniform2(location, values);
	}
	
	public static void glUniform3f(int location, float v0, float v1, float v2)
	{
		GL20.glUniform3f(location, v0, v1, v2);
	}
	
	public static void glUniform3i(int location, int v0, int v1, int v2)
	{
		GL20.glUniform3i(location, v0, v1, v2);
	}
	
	public static void glUniform3(int location, IntBuffer values)
	{
		GL20.glUniform3(location, values);
	}
	
	public static void glUniform3(int location, FloatBuffer values)
	{
		GL20.glUniform3(location, values);
	}
	
	public static void glUniform4f(int location, float v0, float v1, float v2, float v3)
	{
		GL20.glUniform4f(location, v0, v1, v2, v3);
	}
	
	public static void glUniform4i(int location, int v0, int v1, int v2, int v3)
	{
		GL20.glUniform4i(location, v0, v1, v2, v3);
	}
	
	public static void glUniform4(int location, IntBuffer values)
	{
		GL20.glUniform4(location, values);
	}
	
	public static void glUniform4(int location, FloatBuffer values)
	{
		GL20.glUniform4(location, values);
	}
	
	/**
	 * End Uniforms methods.
	 * ============================
	 */


	/**
	 * Get Uniforms matrix methods.
	 * ============================
	 */
	
	public static void glUniformMatrix2(int location, boolean transpose, FloatBuffer matrices)
	{
		GL20.glUniformMatrix2(location, transpose, matrices);
	}
	
	public static void glUniformMatrix3(int location, boolean transpose, FloatBuffer matrices)
	{
		GL20.glUniformMatrix3(location, transpose, matrices);
	}
	
	public static void glUniformMatrix4(int location, boolean transpose, FloatBuffer matrices)
	{
		GL20.glUniformMatrix4(location, transpose, matrices);
	}
	
	/**
	 * End Uniforms matrix methods.
	 * ============================
	 */
	
	/**
	 * MIP mapping (mipmapping) is an anti-aliasing method used in many 3-D rendering 
	 * applications. It is usually used in game visualization and 3-D image rendering. 
	 */
	public static void glGenerateMipmapping(int target)
	{
		GL30.glGenerateMipmap(target);
	}
	
	public static void glGenerateMipmapping()
	{
		GL30.glGenerateMipmap(Texture.TEXTURE_2D);
	}
	
	public static void glTexParametri(int target, int pname, int param)
	{
		GL11.glTexParameteri(target, pname, param);
	}
	
	public static void glTexParametri(int pname, int param)
	{
		GL11.glTexParameteri(Texture.TEXTURE_2D, pname, param);
	}
	
	public static void glTexParametrf(int pname, float param)
	{
		GL11.glTexParameterf(Texture.TEXTURE_2D, pname, param);
	}
	
	/**
	 * Just create a 2d vertices for image.
	 */
	public static void glTexImage2D(int target, int level, int internalformat, 
			int width, int height, int border, int format, int type, ByteBuffer pixels)
	{
		GL11.glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
	}
	
	public static void glTexImage2D(int target, int level, int internalformat, 
			int width, int height, int border, int format, int type, DoubleBuffer pixels)
	{
		GL11.glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
	}
	
	public static void glTexImage2D(int target, int level, int internalformat, 
			int width, int height, int border, int format, int type, FloatBuffer pixels)
	{
		GL11.glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
	}
	
	public static void glTexImage2D(int target, int level, int internalformat, 
			int width, int height, int border, int format, int type, IntBuffer pixels)
	{
		GL11.glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
	}
	
	public static void glDepthMask(boolean flag)
	{
		GL11.glDepthMask(flag);
	}
	
	public static void glVertexAttribDivisor(int index, int divisor)
	{
		GL33.glVertexAttribDivisor(index, divisor);
	}
	
	/**
	 * Buffer for sub data in bytes.
	 */
	public static void glBufferSubData(int target, long offset, ByteBuffer data)
	{
		GL15.glBufferSubData(target, offset, data);
	}
	
	/**
	 * Buffer for sub data in short.
	 */
	public static void glBufferSubData(int target, long offset, ShortBuffer data)
	{
		GL15.glBufferSubData(target, offset, data);
	}
	
	/**
	 * Buffer for sub data in integers.
	 */
	public static void glBufferSubData(int target, long offset, IntBuffer data)
	{
		GL15.glBufferSubData(target, offset, data);
	}
	
	/**
	 * Buffer for sub data in floats.
	 */
	public static void glBufferSubData(int target, long offset, FloatBuffer data)
	{
		GL15.glBufferSubData(target, offset, data);
	}
	
	/**
	 * Buffer for sub data in doubles.
	 */
	public static void glBufferSubData(int target, long offset, DoubleBuffer data)
	{
		GL15.glBufferSubData(target, offset, data);
	}
	
	public static void glDrawArraysInstanced(int mode, int first, int count, int primcount)
	{
		GL31.glDrawArraysInstanced(mode, first, count, primcount);
	}
	
	public static void glFramebufferTexture(int target, int attachment, int texture, int level)
	{
		GL32.glFramebufferTexture(target, attachment, texture, level);
	}

	/**
	 * FBO for a texture 2d.
	 */
	public static void glFramebufferTexture2D(int target, int attachment, int textarget,
			int texture, int level) 
	{
		GL30.glFramebufferTexture2D(target, attachment, textarget, texture, level);
		
	}

	public static void glRenderbufferStorage(int target, int internalformat,
			int width, int height) 
	{
		GL30.glRenderbufferStorage(target, internalformat, width, height);
	}

	public static void glFramebufferRenderbuffer(int target, int attachment, int renderbuffertarget,
			int renderbuffer) 
	{
		GL30.glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
		
	}

	/**
	 * Generate a render buffer.
	 */
	public static int glGenRenderbuffers() 
	{
		return GL30.glGenRenderbuffers();
	}

	/**
	 * Generate a frame buffer.
	 */
	public static int glGenFramebuffers() 
	{
		return GL30.glGenFramebuffers();
	}
	
	public static void glBlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, 
			int mask, int filter)
	{
		GL30.glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
	}

	public static void glRenderbufferStorageMultisample(int target, int samples, int internalformat, int width,
			int height) 
	{
		GL30.glRenderbufferStorageMultisample(target, samples, internalformat, width, height);
	}

	
	/**
	 * Get a error on OpenGl and print id this error.
	 */
	public static int glGetError()
    {
        return GL11.glGetError();
    }

	/**
	 * Just a get OpenGl string.
	 * 
	 * @return - string name.
	 */
    public static String glGetString(int name)
    {
        return GL11.glGetString(name);
    }

    public static void glGetInteger(int parameterName, IntBuffer parameters)
    {
        GL11.glGetInteger(parameterName, parameters);
    }

    public static int glGetInteger(int parameterName)
    {
        return GL11.glGetInteger(parameterName);
    }
    
    public static void glColor4f(float r, float g, float b, float a)
    {
    	GL11.glColor4f(r, g, b, a);
    }
    
    public static float glGetFloat(int pname)
    {
    	return GL11.glGetFloat(pname);
    }
    
    public class Texture
    {
    	/**All used textures id for this engine.*/
    	public static final int TEXTURE0 = GL13.GL_TEXTURE0;
    	public static final int TEXTURE1 = GL13.GL_TEXTURE1;
    	public static final int TEXTURE2 = GL13.GL_TEXTURE2;
    	public static final int TEXTURE3 = GL13.GL_TEXTURE3;
    	public static final int TEXTURE4 = GL13.GL_TEXTURE4;
    	public static final int TEXTURE5 = GL13.GL_TEXTURE5;
    	public static final int TEXTURE6 = GL13.GL_TEXTURE6;
    	
    	/**Generate a texture for reading.*/
    	public static final int TEXTURE_2D = GL11.GL_TEXTURE_2D;
    	public static final int PROXY_TEXTURE_2D = GL11.GL_PROXY_TEXTURE_2D;
    	public static final int TEXTURE_LOD_BIAS = GL14.GL_TEXTURE_LOD_BIAS;
    	public static final int TEXTURE_MAG_FILTER = GL11.GL_TEXTURE_MAG_FILTER;
    	public static final int TEXTURE_MIN_FILTER = GL11.GL_TEXTURE_MIN_FILTER;
    	public static final int TEXTURE_WRAP_S = GL11.GL_TEXTURE_WRAP_S;
    	public static final int TEXTURE_WRAP_T = GL11.GL_TEXTURE_WRAP_T;
    	public static final int TEXTURE_CUBE_MAP = GL13.GL_TEXTURE_CUBE_MAP;
    	public static final int TEXTURE_CUBE_MAP_POSI_X = GL13.GL_TEXTURE_CUBE_MAP_POSITIVE_X;
    	public static final int TEXTURE_CUBE_MAP_POSI_Y = GL13.GL_TEXTURE_CUBE_MAP_POSITIVE_Y;
    	public static final int TEXTURE_CUBE_MAP_POSI_Z = GL13.GL_TEXTURE_CUBE_MAP_POSITIVE_Z;
    	public static final int TEXTURE_CUBE_MAP_NEG_X = GL13.GL_TEXTURE_CUBE_MAP_NEGATIVE_X;
    	public static final int TEXTURE_CUBE_MAP_NEG_Y = GL13.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y;
    	public static final int TEXTURE_CUBE_MAP_NEG_Z = GL13.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z;
    	public static final int LINEAR_MIPMAP_LINEAR = GL11.GL_LINEAR_MIPMAP_LINEAR;
    	public static final int LINEAR_MIPMAP_NEAREST = GL11.GL_LINEAR_MIPMAP_NEAREST;
    	
    	/**This is all draws operations.*/
    	public static final int STREAM_DRAW = GL15.GL_STREAM_DRAW;
    	public static final int STATIC_DRAW = GL15.GL_STATIC_DRAW;
    	public static final int LINEAR = GL11.GL_LINEAR;
    	public static final int NEAREST = GL11.GL_NEAREST;
    	public static final int FILL = GL11.GL_FILL;
    	public static final int LINE = GL11.GL_LINE;
    	public static final int LINES = GL11.GL_LINES;
    	public static final int TRIANGLES = GL11.GL_TRIANGLES;
    	public static final int TRIANGLE_STRIP = GL11.GL_TRIANGLE_STRIP;
    	
    	/**This a colour texture paltirs utils varibles.*/
    	public static final int RGB = GL11.GL_RGB;
    	public static final int RGBA = GL11.GL_RGBA;
    	public static final int RGBA4 = GL11.GL_RGBA4;
    	public static final int RGBA8 = GL11.GL_RGBA8;
    	
    	/**This is sides of showing/render textures.*/
    	public static final int BACK = GL11.GL_BACK;
    	public static final int BACK_LEFT = GL11.GL_BACK_LEFT;
    	public static final int BACK_RIGHT = GL11.GL_BACK_RIGHT;
    	public static final int FRONT = GL11.GL_FRONT;
    	public static final int FRONT_AND_BACK = GL11.GL_FRONT_AND_BACK;
    	public static final int FRONT_FACE = GL11.GL_FRONT_FACE;
    	public static final int LEFT = GL11.GL_LEFT;
    	public static final int RIGHT = GL11.GL_RIGHT;
    	
    	/**Other OpenGL Texture Stuff parametrs here.*/
    	public static final int FLOAT = GL11.GL_FLOAT;
    	public static final int INT = GL11.GL_INT;
    	public static final int ARRAY_BUFFER = GL15.GL_ARRAY_BUFFER;
    	public static final int ELEMENT_ARRAY_BUFFER = GL15.GL_ELEMENT_ARRAY_BUFFER;
    	public static final int UNSIGNED_BYTE = GL11.GL_UNSIGNED_BYTE;
    	public static final int UNSINGED_INT = GL11.GL_UNSIGNED_INT;
    	public static final int COLOR_BUFFER_BIT = GL11.GL_COLOR_BUFFER_BIT;
    	public static final int CLAMP_TO_EDGE = GL12.GL_CLAMP_TO_EDGE;
    	public static final int CLIP_DISTANCE = GL30.GL_CLIP_DISTANCE0;
    }
    
    public class Blend 
    {
    	/**These options allow you to control transparency.*/
    	public static final int BLEND = GL11.GL_BLEND;
    	public static final int BLEND_SRC = GL11.GL_BLEND_SRC;
    	public static final int ONE = GL11.GL_ONE;
    	public static final int ONE_MINUS_SRC_ALPHA = GL11.GL_ONE_MINUS_SRC_ALPHA;
    	public static final int ONE_MINUS_SRC_COLOR = GL11.GL_ONE_MINUS_SRC_COLOR;
    	public static final int SRC_ALPHA = GL11.GL_SRC_ALPHA;
    	public static final int SRC_COLOR = GL11.GL_SRC_COLOR;
    	public static final int ZERO = GL11.GL_ZERO;
    }
    
    public class Framebuffer
    {
    	/**Color attachment id for framebuffer render type.*/
    	public static final int COLOR_ATTACHMENT0 = GL30.GL_COLOR_ATTACHMENT0;
    	public static final int COLOR_ATTACHMENT1 = GL30.GL_COLOR_ATTACHMENT1;
    	public static final int COLOR_ATTACHMENT2 = GL30.GL_COLOR_ATTACHMENT2;
    	public static final int COLOR_ATTACHMENT3 = GL30.GL_COLOR_ATTACHMENT3;
    	public static final int COLOR_ATTACHMENT4 = GL30.GL_COLOR_ATTACHMENT4;
    	public static final int COLOR_ATTACHMENT5 = GL30.GL_COLOR_ATTACHMENT5;
    	public static final int COLOR_ATTACHMENT6 = GL30.GL_COLOR_ATTACHMENT6;
    	
    	/**Create a the buffers and draw this components varibles.*/
    	public static final int FRAMEBUFFER = GL30.GL_FRAMEBUFFER;
    	public static final int RENDERBUFFER = GL30.GL_RENDERBUFFER;  	
    	public static final int DRAW_FRAMEBUFFER = GL30.GL_DRAW_FRAMEBUFFER;
    	public static final int READ_FRAMEBUFFER = GL30.GL_READ_FRAMEBUFFER;
    }
    
    public class Depth
    {
    	/**This is a depth components bits.*/
    	public static final int DEPTH_COMPONENT = GL11.GL_DEPTH_COMPONENT;
    	public static final int DEPTH_COMPONENT16 = GL14.GL_DEPTH_COMPONENT16; 
    	public static final int DEPTH_COMPONENT24 = GL14.GL_DEPTH_COMPONENT24;
    	public static final int DEPTH_COMPONENT32 = GL14.GL_DEPTH_COMPONENT32;
    	public static final int DEPTH_COMPONENT32F = GL30.GL_DEPTH_COMPONENT32F;
    	public static final int DEPTH_ATTACHMENT = GL30.GL_DEPTH_ATTACHMENT;
    	public static final int DEPTH_BUFFER = GL30.GL_DEPTH_BUFFER;
    	public static final int DEPTH_BUFFER_BIT = GL11.GL_DEPTH_BUFFER_BIT;
    }
    
}


